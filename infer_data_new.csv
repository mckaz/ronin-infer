Class,Method,Inferred Type,Original Type,Source Code,Comments
[s]Ronin::Address,parse,(XXX) -> XXX,(String) -> Address,"def self.parse(address)
      first_or_new(:address => address)
    end"
[s]Ronin::Campaign,targeting,(XXX) -> XXX,((Array<String> or String)) -> Array<Campaign>,"def self.targeting(addr)
      all('addresses.address' => addr)
    end"
[s]Ronin::Campaign,targeting_orgs,(XXX) -> XXX,((Array<String> or String)) -> Array<Campaign>,"def self.targeting_orgs(names)
      all('organizations.name' => names)
    end"
[s]Ronin::Config,load,(?XXX) -> (false or nil or true),((String or Symbol)) -> %bot,"def Config.load(name=nil)
      dir, file = if name then [CONFIG_DIR, ""#{name}.rb""]
                  else         [PATH, 'config.rb']
                  end

      path = File.expand_path(File.join(dir,file))
      require path if File.file?(path)
    end"
[s]Ronin::Config,tmp_dir,(?((Array<String> or File or [ to_str: () -> String ]))) -> String,(String) -> String,"def Config.tmp_dir(sub_path=nil)
      if sub_path
        sub_path = File.expand_path(File.join('',sub_path))
        path     = File.join(TMP_DIR,sub_path)

        FileUtils.mkdir_p(path) unless File.exist?(path)
        return path
      end

      return TMP_DIR
    end"
[s]Ronin::Credential,for_user,(XXX) -> XXX,(String) -> Array<Credential>,"def self.for_user(name)
      all('user_name.name' => name)
    end"
[s]Ronin::Credential,with_password,(XXX) -> XXX,(String) -> Array<Credential>,"def self.with_password(password)
      all('password.clear_text' => password)
    end"
[s]Ronin::EmailAddress,extract,(XXX) { (XXX) -> XXX } -> Array<%any>,(String) -> Array<EmailAddress>,"def self.extract(text)
      return enum_for(__method__,text).to_a unless block_given?

      scanner = StringScanner.new(text)

      while scanner.skip_until(Regexp::EMAIL_ADDR)
        yield parse(scanner.matched)
      end

      return nil
    end"
[s]Ronin::EmailAddress,with_hosts,(XXX) -> XXX,((Array<String> or String)) -> Array<EmailAddress>,"def self.with_hosts(names)
      all('host_name.address' => names)
    end"
[s]Ronin::EmailAddress,with_ips,(XXX) -> XXX,((Array<String> or String)) -> Array<EmailAddress>,"def self.with_ips(ips)
      all('ip_addresses.address' => ips)
    end"
[s]Ronin::EmailAddress,with_users,(XXX) -> XXX,((Array<String> or String)) -> Array<EmailAddress>,"def self.with_users(names)
      all('user_name.name' => names)
    end"
[s]Ronin::EmailAddress,parse,"(([ dump: () -> XXX ] and [ split: (String, Number) -> XXX ])) -> XXX",(String) -> EmailAddress,"def self.parse(email)
      user, host = email.split('@',2)

      user.strip!

      if user.empty?
        raise(""email address #{email.dump} must have a user name"")
      end

      host.strip!

      if host.empty?
        raise(""email address #{email.dump} must have a host name"")
      end

      return first_or_new(
        :user_name => UserName.first_or_new(:name => user),
        :host_name => HostName.first_or_new(:address => host)
      )
    end"
[s]Ronin::EmailAddress,from,"(([ dump: () -> XXX ] and [ split: (String, Number) -> XXX ] and [ to_s: () -> String ])) -> XXX",([ to_s: () -> String ]) -> EmailAddress,"def self.from(email)
      email = case email
              when URI::MailTo then email.to
              else                  email.to_s
              end

      return parse(email)
    end"
[s]Ronin::HostName,extract,(XXX) { (XXX) -> XXX } -> Array<%any>,(String) -> Array<HostName>,"def self.extract(text)
      return enum_for(__method__,text).to_a unless block_given?

      scanner = StringScanner.new(text)

      while scanner.skip_until(Regexp::HOST_NAME)
        yield parse(scanner.matched)
      end

      return nil
    end"
[s]Ronin::HostName,with_ips,(XXX) -> XXX,((Array<String> or String)) -> Array<HostName>,"def self.with_ips(ips)
      all('ip_addresses.address' => ips)
    end"
[s]Ronin::HostName,with_ports,(XXX) -> XXX,((Array<Number> or Number)) -> Array<HostName>,"def self.with_ports(numbers)
      all('ports.number' => numbers)
    end"
[s]Ronin::HostName,tld,(XXX) -> XXX,(String) -> Array<HostName>,"def self.tld(name)
      all(:address.like => ""%.#{name}"")
    end"
[s]Ronin::HostName,domain,(XXX) -> XXX,(String) -> Array<HostName>,"def self.domain(name)
      all(:address.like => ""#{name}.%"") |
      all(:address.like => ""%.#{name}.%"")
    end"
[s]Ronin::HostName,lookup,"([ to_s: () -> String ], ?XXX) -> Array<XXX>","((IPAddr or String), String) -> Array<HostName>","def self.lookup(addr,nameserver=nil)
      addr = addr.to_s
      ip = IPAddress.first_or_new(:address => addr)

      resolver = Resolv.resolver(nameserver)
      hosts = begin
                resolver.getnames(addr)
              rescue
                []
              end

      hosts.map! do |name|
        HostName.first_or_create(
          :address => name,
          :ip_addresses => [ip]
        )
      end

      return hosts
    end"
[s]Ronin::Installation,gems,() -> XXX,"() -> Hash<String, Gem::Specification>","def self.gems
      load! if @gems.empty?
      return @gems
    end"
[s]Ronin::Installation,paths,() -> XXX,() -> Set<String>,"def self.paths
      load! if @paths.empty?
      return @paths
    end"
[s]Ronin::Installation,libraries,() -> XXX,() -> Array<String>,"def self.libraries
      gems.keys
    end"
[s]Ronin::Installation,each_file,((Array<String> or File or [ to_str: () -> String ])) { (String) -> XXX } -> Enumerator<%any>,(String) -> Enumerator,"def self.each_file(pattern)
      return enum_for(__method__,pattern) unless block_given?

      # query the installed gems
      paths.each do |gem_path|
        slice_index = gem_path.length + 1

        Dir.glob(File.join(gem_path,pattern)) do |path|
          yield path[slice_index..-1]
        end
      end

      return nil
    end"
[s]Ronin::Installation,each_file_in,"(XXX, ?XXX) { ([ chomp: (String) -> XXX ]) -> XXX } -> Enumerator<%any>","(String, (String or Symbol)) -> Enumerator","def self.each_file_in(directory,ext=nil)
      return enum_for(__method__,directory,ext) unless block_given?

      directory = File.join(directory,File::SEPARATOR)

      pattern = File.join(directory,'**','*')
      pattern << "".#{ext}"" if ext

      each_file(pattern) do |path|
        yield path.sub(directory,'')
      end
    end"
[s]Ronin::Installation,load_gems!,() -> (false or true),() -> (false or true),"def self.load_gems!
      register_gem = lambda { |gem|
        @gems[gem.name] = gem
        @paths << gem.full_gem_path
      }

      ronin_gem = Gem.loaded_specs['ronin']

      # add the main ronin gem
      register_gem[ronin_gem]

      # add any dependent gems
      ronin_gem.dependent_gems.each do |gems|
        register_gem[gems[0]]
      end

      return true
    end"
[s]Ronin::Installation,load_gemspecs!,() -> (false or true),() -> (false or true),"def self.load_gemspecs!
      $LOAD_PATH.each do |lib_dir|
        root_dir = File.expand_path(File.join(lib_dir,'..'))
        gemspec_path = Dir[File.join(root_dir,'ronin*.gemspec')][0]

        if gemspec_path
          # switch into the gem directory, before loading the gemspec
          gem = RDL.type_cast(Dir.chdir(root_dir) do
            Gem::Specification.load(gemspec_path)
          end, ""Gem::Specification"")

          # do not add duplicate ronin gems
          unless @gems.has_key?(gem.name)
            @gems[gem.name] = gem
            @paths << root_dir
          end
        end
      end

      return true
    end"
[s]Ronin::Installation,load!,() -> (false or true),() -> (false or true),"def self.load!
      if Gem.loaded_specs.has_key?('ronin') then load_gems!
      else                                       load_gemspecs!
      end
    end"
[s]Ronin::IPAddress,extract,"(XXX, ?XXX) { (XXX) -> XXX } -> Array<%any>","(String, (Number or Symbol)) -> %bot","def self.extract(text,version=nil)
      return enum_for(__method__,text,version).to_a unless block_given?

      IPAddr.extract(text,version) do |ip|
        yield parse(ip)
      end

      return nil
    end"
[s]Ronin::IPAddress,v4,() -> XXX,() -> Array<IPAddress>,"def self.v4
      all(:version => 4)
    end"
[s]Ronin::IPAddress,v6,() -> XXX,() -> Array<IPAddress>,"def self.v6
      all(:version => 6)
    end"
[s]Ronin::IPAddress,with_macs,(XXX) -> XXX,((Array<String> or String)) -> Array<IPAddress>,"def self.with_macs(macs)
      all('mac_addresses.address' => macs)
    end"
[s]Ronin::IPAddress,with_hosts,(XXX) -> XXX,((Array<String> or String)) -> Array<IPAddress>,"def self.with_hosts(names)
      all('host_names.address' => names)
    end"
[s]Ronin::IPAddress,with_ports,(XXX) -> XXX,((Array<Number> or Number)) -> Array<IPAddress>,"def self.with_ports(numbers)
      all('ports.number' => numbers)
    end"
[s]Ronin::IPAddress,lookup,"(XXX, ?XXX) -> Array<XXX>","(String, String) -> Array<IPAddress>","def self.lookup(name,nameserver=nil)
      host = HostName.first_or_new(:address => name)
      resolver = Resolv.resolver(nameserver)

      ips = begin
              resolver.getaddresses(name)
            rescue
              []
            end
        
      ips.map! do |addr|
        IPAddress.first_or_create(
          :address => addr,
          :host_names => [host]
        )
      end

      return ips
    end"
[s]Ronin::MACAddress,extract,(XXX) { (XXX) -> XXX } -> Array<%any>,(String) -> Array<MACAddress>,"def self.extract(text)
      return enum_for(__method__,text).to_a unless block_given?

      scanner = StringScanner.new(text)

      while scanner.skip_until(Regexp::MAC)
        yield parse(scanner.matched)
      end

      return nil
    end"
[s]Ronin::Password,parse,([ to_s: () -> String ]) -> XXX,([ to_s: () -> String ]) -> Password,"def self.parse(password)
      first_or_new(:clear_text => password.to_s)
    end"
[s]Ronin::Port,from,(XXX) -> XXX,((Number or String)) -> Port,"def self.from(number)
      first_or_new(:number => number)
    end"
[s]Ronin::Port,parse,([ to_i: () -> Number ]) -> XXX,((Number or String)) -> Port,"def self.parse(number)
      from(number.to_i)
    end"
[s]Ronin::Repository,find,(([ dump: () -> XXX ] and [ to_s: () -> String ])) -> XXX,(String) -> Repository,"def Repository.find(name)
      name, domain = name.to_s.split('@',2)

      query = {:name => name}
      query[:domain] = domain if domain

      unless (repo = Repository.first(query))
        if domain
          raise(RepositoryNotFound,""Repository #{name.dump} from domain #{domain.dump} cannot be found"")
        else
          raise(RepositoryNotFound,""Repository #{name.dump} cannot be found"")
        end
      end

      return repo
    end"
[s]Ronin::Repository,add,"(?([ []: (:path) -> XXX ] and [ has_key?: (:path) -> XXX ] and [ merge: ({ path: Pathname, installed: (false or true), domain: String }) -> XXX ])) -> Ronin::Repository",() -> Repository,"def Repository.add(options={})
      unless options.has_key?(:path)
        raise(ArgumentError,""the :path option was not given"")
      end

      path = Pathname.new(options[:path]).expand_path

      unless path.directory?
        raise(RepositoryNotFound,""Repository #{path} cannot be found"")
      end

      if Repository.count(:path => path) > 0
        raise(DuplicateRepository,""a Repository at the path #{path} was already added"")
      end

      # create the repository
      repo = Repository.new(options.merge(
        :path      => path,
        :installed => false,
        :domain    => LOCAL_DOMAIN
      ))

      if Repository.count(:name => repo.name, :domain => repo.domain) > 0
        raise(DuplicateRepository,""the Repository #{repo} already exists in the database"")
      end

      # save the repository
      if repo.save
        # cache any files from within the `cache/` directory of the
        # repository
        repo.cache_scripts!
      end

      return repo
    end"
[s]Ronin::Repository,install,(?[ []: (:uri) -> XXX ]) -> Ronin::Repository,(Hash) -> Repository,"def Repository.install(options={})
      unless options[:uri]
        raise(ArgumentError,"":uri must be passed to Repository.install"")
      end

      remote_repo = Pullr::RemoteRepository.new(options)

      name   = remote_repo.name
      domain = if remote_repo.uri.scheme
                 remote_repo.uri.host
               else
                 # Use a regexp to pull out the host-name, if the URI
                 # lacks a scheme.
                 remote_repo.uri.to_s.match(/\@([^@:\/]+)/)[1]
               end

      if Repository.count(:name => name, :domain => domain) > 0
        raise(DuplicateRepository,""a Repository already exists with the name #{name.dump} from domain #{domain.dump}"")
      end

      path = File.join(Config::REPOS_DIR,name,domain)

      # pull down the remote repository
      local_repo = remote_repo.pull(path)

      # add the new remote repository
      repo = Repository.new(
        :path      => path,
        :scm       => local_repo.scm,
        :uri       => remote_repo.uri,
        :installed => true,
        :name      => name,
        :domain    => domain
      )

      # save the repository 
      if repo.save
        # cache any files from within the `cache/` directory of the
        # repository
        repo.cache_scripts!
      end

      return repo
    end"
[s]Ronin::Repository,update!,() { ([ update!: () -> XXX ]) -> XXX } -> XXX,() -> %bot,"def Repository.update!
      Repository.each do |repo|
        # update the repositories contents
        repo.update!

        yield repo if block_given?
      end
    end"
[s]Ronin::Repository,uninstall,(([ dump: () -> XXX ] and [ to_s: () -> String ])) -> XXX,(String) -> nil,"def Repository.uninstall(name)
      Repository.find(name).uninstall!
    end"
[s]Ronin::Repository,activate!,() -> XXX,() -> Array<Repository>,"def Repository.activate!
      Repository.each { |repo| repo.activate! }
    end"
[s]Ronin::Repository,deactivate!,() -> Enumerator<t>,() -> Array<Repository>,"def Repository.deactivate!
      Repository.reverse_each { |repo| repo.deactivate! }
    end"
[s]Ronin::URL,extract,(String) { (XXX) -> XXX } -> Array<%any>,(String) -> Array<URL>,"def self.extract(text)
      return enum_for(__method__,text).to_a unless block_given?

      ::URI.extract(text) do |uri|
        uri = begin
                ::URI.parse(RDL.type_cast(uri, ""String""))
              rescue URI::InvalidURIError
                # URI.extract can parse URIs that URI.parse cannot handle
                next
              end

        yield from(RDL.type_cast(uri, ""URI::HTTP""))
      end

      return nil
    end"
[s]Ronin::URL,http,() -> XXX,() -> Array<URL>,"def self.http
      all('scheme.name' => 'http')
    end"
[s]Ronin::URL,https,() -> XXX,() -> Array<URL>,"def self.https
      all('scheme.name' => 'https')
    end"
[s]Ronin::URL,hosts,(XXX) -> XXX,((Array<String> or String)) -> Array<URL>,"def self.hosts(names)
      all('host.address' => names)
    end"
[s]Ronin::URL,ports,(XXX) -> XXX,((Array<Number> or Number)) -> Array<URL>,"def self.ports(numbers)
      all('port.number' => numbers)
    end"
[s]Ronin::URL,directory,(XXX) -> XXX,(String) -> Array<URL>,"def self.directory(root_dir)
      all(:path => root_dir) | all(:path.like => ""#{root_dir}/%"")
    end"
[s]Ronin::URL,extension,(XXX) -> Array<URL>,(String) -> Array<URL>,"def self.extension(ext)
      RDL.type_cast(all(:path => ""%.#{ext}""), ""Array<URL>"")
    end"
[s]Ronin::URL,with_query_param,(XXX) -> XXX,((Array<String> or String)) -> Array<URL>,"def self.with_query_param(name)
      all('query_params.name.name' => name)
    end"
[s]Ronin::URL,with_query_value,(XXX) -> XXX,((Array<String> or String)) -> Array<URL>,"def self.with_query_value(value)
      all('query_params.value' => value)
    end"
[s]Ronin::URL,query_param,(XXX) -> XXX,() -> %bot,"def self.query_param(name)
      with_query_param(name)
    end"
[s]Ronin::URL,query_value,(XXX) -> XXX,() -> %bot,"def self.query_value(value)
      with_query_value(name)
    end"
[s]Ronin::URL,from,(([ fragment: () -> XXX ] and [ host: () -> XXX ] and [ path: () -> XXX ] and [ port: () -> XXX ] and [ query_params: () -> XXX ] and [ respond_to?: (:query_params) -> XXX ] and [ scheme: () -> XXX ])) -> XXX,(URI::HTTP) -> URL,"def self.from(uri)
      # find or create the URL scheme, host_name and port
      scheme    = URLScheme.first_or_new(:name => uri.scheme)
      host_name = HostName.first_or_new(:address => uri.host)
      port      = if uri.port
                    TCPPort.first_or_new(:number => uri.port)
                  end

      path     = normalized_path(uri)
      fragment = uri.fragment

      query_params = []
      
      if uri.respond_to?(:query_params)
        # find or create the URL query params
        uri.query_params.each do |name,value|
          query_params << {
            :name  => URLQueryParamName.first_or_new(:name => name),
            :value => value
          }
        end
      end

      # find or create the URL
      return first_or_new(
        :scheme       => scheme,
        :host_name    => host_name,
        :port         => port,
        :path         => path,
        :fragment     => fragment,
        :query_params => query_params
      )
    end"
[s]Ronin::URL,parse,(String) -> XXX,(String) -> URL,"def self.parse(url)
      from(::URI.parse(url))
    end"
[s]Ronin::URL,normalized_path,([ path: () -> XXX ]) -> String,(URI) -> String,"def self.normalized_path(uri)
      case uri
      when ::URI::HTTP
        # map empty HTTP paths to '/'
        unless uri.path.empty? then uri.path
        else                        '/'
        end
      else
        uri.path
      end
    end"
[s]Ronin::WebCredential,with_email,"(([ dump: () -> XXX ] and [ include?: (String) -> XXX ] and [ split: (String, Number) -> XXX ])) -> XXX",(String) -> Array<WebCredential>,"def self.with_email(email)
      unless email.include?('@')
        raise(""invalid email address #{email.dump}"")
      end

      user, domain = email.split('@',2)

      return all(
        'email_address.user_name.name' => user,
        'email_address.host_name.address' => domain
      )
    end"
[s]Ronin::Database,repositories,() -> XXX,"() -> Hash<Symbol, Hash>","def self.repositories
      if @repositories.empty?
        @repositories[:default] = DEFAULT_REPOSITORY

        if File.file?(CONFIG_FILE)
          config = YAML.load_file(CONFIG_FILE)

          unless config.kind_of?(Hash)
            raise(InvalidConfig,""#{CONFIG_FILE} must contain a YAML Hash of repositories"")
          end

          config.each do |name,uri|
            @repositories[name.to_sym] = uri
          end
        end
      end

      return @repositories
    end"
[s]Ronin::Database,repository?,([ to_sym: () -> XXX ]) -> XXX,((String or Symbol)) -> (false or true),"def self.repository?(name)
      repositories.has_key?(name.to_sym)
    end"
[s]Ronin::Database,save,() { () -> XXX } -> (false or true),() -> (false or true),"def self.save
      yield if block_given?

      File.open(CONFIG_FILE,'w') do |file|
        hash = {}
        
        repositories.each do |name,value|
          hash[name.to_sym] = value
        end

        YAML.dump(hash,file)
      end

      return true
    end"
[s]Ronin::Database,log,"(?([ empty?: () -> XXX ] and [ fetch: (:level, :info) -> XXX ] and [ fetch: (:path, String) -> XXX ] and [ fetch: (:stream, XXX) -> XXX ])) -> DataMapper::Logger",(Hash) -> DataMapper::Logger,"def self.log(options={})
      unless (@log && options.empty?)
        path   = options.fetch(:path,DEFAULT_LOG_PATH)
        stream = options.fetch(:stream,File.new(path,'w+'))
        level  = options.fetch(:level,DEFAULT_LOG_LEVEL)

        @log = DataMapper::Logger.new(stream,level)
      end

      return @log
    end"
[s]Ronin::Database,upgrade!,() -> (false or true),() -> (false or true),"def self.upgrade!
      return false unless setup?

      Migrations.migrate_up!
    end"
[s]Ronin::Database,setup,(?XXX) -> (false or true),((Hash or String)) -> %bot,"def self.setup(uri=nil)
      # setup the database log
      unless @log
        if $DEBUG then log(:stream => $stderr, :level => :debug)
        else           log
        end
      end

      if uri
        # only setup the default database repositories
        DataMapper.setup(:default,uri)
      else
        # setup the database repositories
        repositories.each do |name,uri|
          DataMapper.setup(name,uri)
        end
      end

      # finalize the Models
      DataMapper.finalize

      # apply any new migrations to the database
      upgrade!
    end"
[s]Ronin::Database,repository,([ to_sym: () -> XXX ]) { XXX } -> XXX,((String or Symbol)) -> DataMapper::Repository,"def self.repository(name,&block)
      name = name.to_sym

      unless repository?(name)
        raise(UnknownRepository,""unknown database repository #{name}"")
      end

      return DataMapper.repository(name,&block)
    end"
[s]Ronin::Database,clear,([ to_sym: () -> XXX ]) { () -> XXX } -> nil,((String or Symbol)) -> nil,"def self.clear(name)
      name = name.to_sym

      unless repository?(name)
        raise(UnknownRepository,""unknown database repository #{name}"")
      end

      DataMapper.auto_migrate!(name)

      yield if block_given?
      return nil
    end"
[s]Ronin::Database,map,() { () -> XXX } -> Array<XXX>,() -> Array,"def self.map
      results = []

      repositories.each_key do |name|
        DataMapper.repository(name) do
          result = yield
          results << result unless result.nil?
        end
      end

      return results
    end"
[s]Ronin::Model,included,"(([ <: (Module) -> XXX ] and [ send: (:extend, Module) -> XXX ] and [ send: (:include, Module) -> XXX ] and [ send: (:include, Module, Module, Module) -> XXX ])) -> XXX",(Class) -> %bot,"def self.included(base)
      unless base < DataMapper::Resource
        base.send :include, DataMapper::Resource
      end

      # include DataMapper plugins
      base.send :include, DataMapper::Migrations,
                          DataMapper::Serialize,
                          DataMapper::Timestamps

      # include Model types / methods
      base.send :include, Model::Types
      base.send :include, InstanceMethods
      base.send :extend,  ClassMethods
    end"
[s]Ronin::Script,load_from,(([ dump: () -> XXX ] and [ to_str: () -> String ])) -> XXX,(String) -> Script,"def Script.load_from(path)
      path = File.expand_path(path)
      script = ObjectLoader.load_objects(path).find do |obj|
        obj.class < Script
      end

      unless script
        raise(""No cacheable object defined in #{path.dump}"")
      end

      script.instance_variable_set('@script_loaded',true)
      script.script_path = Path.new(
        :path => path,
        :timestamp => File.mtime(path),
        :class_name => script.class.to_s
      )

      return script
    end"
[s]Ronin::UI::CLI,commands,() -> XXX,() -> Hash,"def CLI.commands
        if @commands.empty?
          commands_dir = File.join('lib',Commands.namespace_root)

          Installation.each_file_in(commands_dir,'rb') do |path|
            # remove the .rb file extension
            name = path.chomp('.rb')

            # replace any file separators with a ':', to mimic the
            # naming convention of Rake/Thor.
            name.tr!(File::SEPARATOR,':')

            @commands << name
          end
        end

        return @commands.sort
      end"
[s]Ronin::UI::CLI,command,"(([ dump: () -> XXX ] and [ to_s: () -> String ] and [ tr: (String, String) -> XXX ])) -> XXX",((String or Symbol)) -> Command,"def CLI.command(name)
        name = name.to_s
        path = name.tr(':','/')

        unless (command = Commands.require_const(path))
          raise(UnknownCommand,""unable to load the command #{name.dump}"",caller)
        end

        unless command.respond_to?(:start)
          raise(UnknownCommand,""command #{name.dump} must provide a 'start' method"",caller)
        end

        return command
      end"
[s]Ronin::UI::CLI,start,(?([ []: (Range<Number>) -> XXX ] and [ first: () -> XXX ])) -> (false or true),(Array) -> (false or true),"def CLI.start(argv=ARGV)
        name = argv.first

        # run the default command if an option or no arguments were given
        if (name.nil? || name[0,1] == '-')
          name = DEFAULT_COMMAND
        else
          argv = argv[1..-1]
        end

        begin
          CLI.command(name).start(argv)
        rescue UnknownCommand => e
          $stderr.puts e.message
          exit -1
        end

        return true
      end"
[s]Ronin::UI::CLI::ClassCommand,class_name,(?[ to_sym: () -> XXX ]) -> Symbol,(Symbol) -> Symbol,"def self.class_name(name=nil)
          if name then @class_name = name.to_sym
          else         @class_name ||= self.name.split('::').last.to_sym
          end
        end"
[s]Ronin::UI::CLI::ClassCommand,command_class,() -> XXX,() -> Class,"def self.command_class
          @command_class ||= class_namespace.const_get(class_name)
        end"
[s]Ronin::UI::CLI::Command,command_name,() -> XXX,() -> %bot,"def self.command_name
          @command_name ||= Support::Inflector.underscore(
            self.name.sub('Ronin::UI::CLI::Commands::','').gsub('::',':')
          )
        end"
[s]Ronin::UI::CLI::Command,start,(?XXX) -> (false or true),(Array<String>) -> (false or true),"def self.start(argv=ARGV)
          new().start(argv)
        end"
[s]Ronin::UI::CLI::Command,run,(?XXX) -> (false or true),"(Hash<Symbol, Object>) -> (false or true)","def self.run(options={})
          new().run(options)
        end"
[s]Ronin::UI::CLI::Command,options,"() -> Hash<:import, { flag: XXX, usage: XXX }>","() -> Hash<Symbol, Hash>","def self.options
          @options ||= {}
        end"
[s]Ronin::UI::CLI::Command,option,"(:import, ?([ []: (:flag) -> XXX ] and [ []: (:usage) -> XXX ])) -> XXX","(Symbol, Hash) -> Parameters::ClassParam","def self.option(name,options={})
          self.options[name] = {
            :flag  => options[:flag],
            :usage => options[:usage],
          }

          return parameter(name,options)
        end"
[s]Ronin::UI::CLI::Command,options?,() -> XXX,() -> (false or true),"def self.options?
          each_option.any?
        end"
[s]Ronin::UI::CLI::Command,arguments,() -> Array<XXX>,() -> Array<Symbol>,"def self.arguments
          @arguments ||= []
        end"
[s]Ronin::UI::CLI::Command,argument,"([ to_sym: () -> XXX ], ?XXX) -> XXX","(Symbol, Hash) -> Parameters::ClassParam","def self.argument(name,options={})
          self.arguments << name.to_sym

          return parameter(name,options)
        end"
[s]Ronin::UI::CLI::Command,arguments?,() -> XXX,() -> (false or true),"def self.arguments?
          each_argument.any?
        end"
[s]Ronin::UI::CLI::ModelCommand,query_options,() -> Array<:import>,() -> Array<Symbol>,"def self.query_options
          @query_options ||= []
        end"
[s]Ronin::UI::CLI::ModelCommand,query_option,"(:import, ?([ []: (:flag) -> XXX ] and [ []: (:usage) -> XXX ])) -> XXX","(Symbol, Hash) -> %bot","def self.query_option(name,options={})
          query_options << name

          return option(name,options)
        end"
[s]Ronin::UI::CLI::ResourcesCommand,model,(?[ <: (Module) -> XXX ]) -> XXX,() -> %bot,"def self.model(model=nil)
          if (model && model < Model::Importable)
            option :import, :type  => String,
                            :flag  => '-i',
                            :usage => 'FILE',
                            :description => 'The file to import'
          end

          return super(model)
        end"
[s]Ronin::UI::CLI::ScriptCommand,script_class,(?[ included_modules: () -> XXX ]) -> XXX,(Script) -> Script,"def self.script_class(script=nil)
          if (script && !script.included_modules.include?(Script))
            raise(ArgumentError,""#{script} does not include Ronin::Script"")
          end

          return model(script)
        end"
[s]Ronin::UI::CLI::Commands::Exec,start,(?([ []: (Number) -> XXX ] and [ []: (Range<Number>) -> XXX ])) -> (false or true),(Array<String>) -> %bot,"def self.start(argv=ARGV)
            case argv[0]
            when '-h', '--help', nil
              puts ""Usage:\n  ronin-exec SCRIPT [ARGS...]\n\n""
              puts ""Runs a script from a Ronin Repository""
              return false
            end

            self.new(argv[0],argv[1..-1]).execute
          end"
Ronin,script,(([ dump: () -> XXX ] and [ to_str: () -> String ])) -> XXX,(String) -> Script,"def script(path)
    Script.load_from(path)
  end"
Ronin::Address,to_s,() -> String,() -> String,"def to_s
      self.address.to_s
    end"
Ronin::Address,inspect,() -> String,() -> String,"def inspect
      ""#<#{self.class}: #{self.address}>""
    end"
Ronin::Author,to_s,() -> String,() -> String,"def to_s
      if self.email then ""#{self.name} <#{self.email}>""
      else               super
      end
    end"
Ronin::Campaign,targets?,(XXX) -> XXX,(Address) -> (false or true),"def targets?(address)
      self.addresses.include?(address)
    end"
Ronin::Campaign,target!,([ dump: () -> XXX ]) -> XXX,(String) -> Target,"def target!(addr)
      unless (address = Address.first(:address => addr))
        raise(""unknown address #{addr.dump}"")
      end

      return Target.first_or_create(:campaign => self, :address => address)
    end"
Ronin::Credential,user,() -> nil,() -> String,"def user
      self.user_name.name if self.user_name
    end"
Ronin::Credential,clear_text,() -> nil,() -> String,"def clear_text
      self.password.clear_text if self.password
    end"
Ronin::Credential,to_s,() -> String,() -> String,"def to_s
      ""#{self.user_name}:#{self.password}""
    end"
Ronin::EmailAddress,user,() -> nil,() -> String,"def user
      self.user_name.name if self.user_name
    end"
Ronin::EmailAddress,host,() -> nil,() -> String,"def host
      self.host_name.address if self.host_name
    end"
Ronin::EmailAddress,to_s,() -> String,() -> String,"def to_s
      ""#{self.user_name}@#{self.host_name}""
    end"
Ronin::EmailAddress,inspect,() -> String,() -> String,"def inspect
      ""#<#{self.class}: #{self}>""
    end"
Ronin::HostName,lookup!,(?XXX) -> Array<XXX>,(String) -> Array<IPAddress>,"def lookup!(nameserver=nil)
      resolver = Resolv.resolver(nameserver)
      ips = begin
              resolver.getaddresses(self.address)
            rescue
              []
            end

      ips.map! do |addr|
        IPAddress.first_or_create(
          :address => addr,
          :host_names => [self]
        )
      end

      return ips
    end"
Ronin::HostName,recent_ip_address,() -> XXX,() -> IpAddress,"def recent_ip_address
      self.host_name_ip_addresses.all(
        :order => [:created_at.desc]
      ).ip_addresses.first
    end"
Ronin::HostName,last_scanned_at,() -> nil,() -> Time,"def last_scanned_at
      last_scanned_url = self.urls.first(
        :order => [:last_scanned_at.desc]
      )

      return last_scanned_url.last_scanned_at if last_scanned_url
    end"
Ronin::IPAddress,lookup!,(?XXX) -> Array<XXX>,(String) -> Array<HostName>,"def lookup!(nameserver=nil)
      resolver = Resolv.resolver(nameserver)
      hosts = begin
                resolver.getnames(self.address.to_s)
              rescue
                []
              end

      hosts.map! do |name|
        HostName.first_or_create(
          :address => name,
          :ip_addresses => [self]
        )
      end

      return hosts
    end"
Ronin::IPAddress,recent_mac_address,() -> XXX,() -> MacAddress,"def recent_mac_address
      self.ip_address_mac_addresses.all(
        :order => [:created_at.desc]
      ).mac_addresses.first
    end"
Ronin::IPAddress,recent_host_name,() -> XXX,() -> HostName,"def recent_host_name
      self.host_name_ip_addresses.all(
        :order => [:created_at.desc]
      ).host_names.first
    end"
Ronin::IPAddress,recent_os_guess,() -> XXX,() -> OS,"def recent_os_guess
      self.os_guesses.all(:order => [:created_at.desc]).oses.first
    end"
Ronin::IPAddress,last_scanned_at,() -> nil,() -> Time,"def last_scanned_at
      last_scanned_port = self.open_ports.first(
        :order => [:last_scanned_at.desc]
      )

      return last_scanned_port.last_scanned_at if last_scanned_port
    end"
Ronin::IPAddress,to_ip,() -> XXX,() -> IPAddr,"def to_ip
      self.address
    end"
Ronin::IPAddress,to_i,() -> Number,() -> Number,"def to_i
      self.address.to_i
    end"
Ronin::MACAddress,recent_ip_address,() -> XXX,() -> IpAddress,"def recent_ip_address
      self.ip_address_mac_addresses.all(
        :order => [:created_at.desc]
      ).ip_addresses.first
    end"
Ronin::MACAddress,to_i,() -> XXX,() -> Number,"def to_i
      self.address.split(':').inject(0) do |bits,char|
        bits = ((bits << 8) | char.hex)
      end
    end"
Ronin::OpenPort,address,() -> XXX,() -> String,"def address
      self.ip_address.address
    end"
Ronin::OpenPort,number,() -> XXX,() -> Number,"def number
      self.port.number
    end"
Ronin::OpenPort,to_i,() -> Number,() -> Number,"def to_i
      self.port.to_i
    end"
Ronin::OpenPort,to_s,() -> String,() -> String,"def to_s
      if self.service then ""#{self.port} (#{self.service})""
      else                 ""#{self.port}""
      end
    end"
Ronin::OS,recent_ip_address,() -> nil,() -> IPAddress,"def recent_ip_address
      relation = self.os_guesses.first(:order => [:created_at.desc])

      if relation
        return relation.ip_address
      end
    end"
Ronin::OS,to_s,() -> String,() -> String,"def to_s
      if self.version then ""#{self.name} #{self.version}""
      else                 super
      end
    end"
Ronin::Password,digest,"([ to_s: () -> String ], ?([ []: (:append_salt) -> XXX ] and [ []: (:prepend_salt) -> XXX ])) -> XXX","((String or Symbol), Hash) -> String","def digest(algorithm,options={})
      digest_class = begin
                       Digest.const_get(algorithm.to_s.upcase)
                     rescue LoadError
                       raise(ArgumentError,""Unknown Digest algorithm #{algorithm}"")
                     end

      hash = RDL.type_cast(digest_class, ""Class"").new

      if options[:prepend_salt]
        hash << options[:prepend_salt].to_s
      end

      hash << self.clear_text

      if options[:append_salt]
        hash << options[:append_salt].to_s
      end

      return hash.hexdigest
    end"
Ronin::Password,count,() -> XXX,() -> Number,"def count
      self.credentials.count
    end"
Ronin::Password,to_s,() -> XXX,() -> String,"def to_s
      self.clear_text
    end"
Ronin::Password,inspect,() -> String,() -> String,"def inspect
      ""#<#{self.class}: #{self.clear_text}>""
    end"
Ronin::Port,to_i,() -> Number,() -> Number,"def to_i
      self.number.to_i
    end"
Ronin::Port,to_s,() -> String,() -> String,"def to_s
      ""#{self.number}/#{self.protocol}""
    end"
Ronin::Port,inspect,() -> String,() -> String,"def inspect
      ""#<#{self.class}: #{self}>""
    end"
Ronin::Repository,local?,() -> (false or true),() -> (false or true),"def local?
      self.domain == LOCAL_DOMAIN
    end"
Ronin::Repository,remote?,() -> XXX,() -> (false or true),"def remote?
      self.domain != LOCAL_DOMAIN
    end"
Ronin::Repository,executables,() -> Array<String>,() -> Array<String>,"def executables
      scripts = []

      if @bin_dir.directory?
        @bin_dir.entries.each do |path|
          scripts << path.basename.to_s if path.file?
        end
      end

      return scripts
    end"
Ronin::Repository,each_script,() { XXX } -> Enumerator<%any>,() -> Enumerator,"def each_script(&block)
      return enum_for(__method__) unless block

      @script_dirs.each do |dir|
        Pathname.glob(dir.join('**','*.rb'),&block)
      end
    end"
Ronin::Repository,activated?,() -> (false or true),() -> (false or true),"def activated?
      @activated == true
    end"
Ronin::Repository,deactivate!,() -> (false or true),() -> %bot,"def deactivate!
      unregister_data_paths

      $LOAD_PATH.delete(@lib_dir.to_s)

      @activated = false
      return true
    end"
Ronin::Repository,find_script,((Array<String> or File or [ to_str: () -> String ])) -> XXX,(String) -> Script::Path,"def find_script(sub_path)
      paths = @script_dirs.map { |dir| File.join(dir,sub_path) }

      return script_paths.first(:path => paths)
    end"
Ronin::Repository,cache_scripts!,() -> Ronin::Repository,() -> Repository,"def cache_scripts!
      clean_scripts!

      each_script do |path|
        self.script_paths.new(:path => path).cache
      end

      return self
    end"
Ronin::Repository,sync_scripts!,() -> Ronin::Repository,() -> Repository,"def sync_scripts!
      # activates the repository before caching it's objects
      activate!

      new_paths = each_script.to_a

      self.script_paths.each do |script_path|
        # filter out pre-existing paths within the `cached/` directory
        new_paths.delete(script_path.path)

        # sync the cached file and catch any exceptions
        script_path.sync
      end

      # cache the new paths within the `cache/` directory
      new_paths.each do |path|
        self.script_paths.new(:path => path).cache
      end

      # deactivates the repository
      deactivate!
      return self
    end"
Ronin::Repository,clean_scripts!,() -> Ronin::Repository,() -> Repository,"def clean_scripts!
      self.script_paths.destroy
      self.script_paths.clear
      return self
    end"
Ronin::Repository,update!,() { (Ronin::Repository) -> XXX } -> Ronin::Repository,() -> Repository,"def update!
      local_repo = Pullr::LocalRepository.new(
        :path => self.path,
        :scm  => self.scm
      )

      # only update if we have a repository
      local_repo.update(self.uri)

      # re-initialize the metadata
      initialize_metadata

      # save the repository
      if save
        # syncs the cached files of the repository
        sync_scripts!
      end

      yield self if block_given?
      return self
    end"
Ronin::Repository,uninstall!,() { (Ronin::Repository) -> XXX } -> Ronin::Repository,() -> Repository,"def uninstall!
      deactivate!

      FileUtils.rm_rf(self.path) if self.installed?

      # destroy any cached files first
      clean_scripts!

      # remove the repository from the database
      destroy if saved?

      yield self if block_given?
      return self
    end"
Ronin::Repository,to_s,() -> String,() -> String,"def to_s
      ""#{self.name}/#{self.domain}""
    end"
Ronin::Repository,initialize_metadata,() -> Ronin::Repository,() -> %bot,"def initialize_metadata
      metadata_path = self.path.join(METADATA_FILE)

      self.title       = self.name
      self.description = nil
      self.license     = nil

      self.source  = self.uri
      self.website = self.source
      self.authors.clear

      if File.file?(metadata_path)
        metadata = RDL.type_cast(YAML.load_file(metadata_path), ""Hash<String, String>"")

        if (title = metadata['title'])
          self.title = title
        end

        if (description = metadata['description'])
          self.description = description
        end

        if (license = metadata['license'])
          self.license = License.first_or_predefined(:name => license)
        end

        if (uri = metadata['uri'])
          self.uri ||= uri
        end

        if (source = metadata['source'])
          self.source = source
        end

        if (website = metadata['website'])
          self.website = website
        end

        case metadata['authors']
        when Hash
          RDL.type_cast(metadata['authors'], ""Hash<String, String>"").each do |name,email|
            self.authors << Author.first_or_new(:name => name, :email => email)
          end
        when Array
          RDL.type_cast(metadata['authors'], ""Array<String>"").each do |name|
            self.authors << Author.first_or_new(:name => name)
          end
        end
      end

      return self
    end"
Ronin::Software,to_s,() -> String,() -> String,"def to_s
      [self.vendor, self.name, self.version].compact.join(' ')
    end"
Ronin::Target,to_s,() -> String,() -> String,"def to_s
      self.address.to_s
    end"
Ronin::URL,host,() -> XXX,() -> String,"def host
      self.host_name.address
    end"
Ronin::URL,port_number,() -> nil,() -> Number,"def port_number
      self.port.number if self.port
    end"
Ronin::URL,query_string,() -> XXX,() -> String,"def query_string
      params = {}

      self.query_params.each do |param|
        params[param.name] = param.value
      end

      return ::URI::QueryParams.dump(params)
    end"
Ronin::URL,query_string=,(XXX) -> XXX,(String) -> String,"def query_string=(query)
      self.query_params.clear

      ::URI::QueryParams.parse(query).each do |name,value|
        self.query_params.new(
          :name  => URLQueryParamName.first_or_new(:name => name),
          :value => value
        )
      end

      return query
    end"
Ronin::URL,to_uri,() -> XXX,() -> URI::HTTP,"def to_uri
      # map the URL scheme to a URI class
      url_class = SCHEMES.fetch(self.scheme.name,::URI::Generic)

      host = if self.host_name
               self.host_name.address
             end
      port = if self.port
               self.port.number
             end

      query = unless self.query_params.empty?
                self.query_string
              end

      # build the URI
      return url_class.build(
        :scheme   => self.scheme.name,
        :host     => host,
        :port     => port,
        :path     => self.path,
        :query    => query,
        :fragment => self.fragment
      )
    end"
Ronin::URL,to_s,() -> String,() -> String,"def to_s
      self.to_uri.to_s
    end"
Ronin::URL,inspect,() -> String,() -> String,"def inspect
      ""#<#{self.class}: #{self}>""
    end"
Ronin::URLQueryParam,to_s,() -> XXX,() -> String,"def to_s
      URI::QueryParams.dump(self.name.to_s => self.value)
    end"
Ronin::URLQueryParam,inspect,() -> String,() -> String,"def inspect
      ""#<#{self.class}: #{self}>""
    end"
Ronin::URLQueryParamName,created_at,() -> nil,() -> Time,"def created_at
      if (url = self.query_params.urls.first(:fields => [:created_at]))
        url.created_at
      end
    end"
Ronin::URLQueryParamName,to_s,() -> String,() -> String,"def to_s
      self.name.to_s
    end"
Ronin::URLQueryParamName,inspect,() -> String,() -> String,"def inspect
      ""#<#{self.class}: #{self}>""
    end"
Ronin::WebCredential,to_s,() -> String,() -> String,"def to_s
      if self.email_address then ""#{super} (#{self.email_address})""
      else                       super
      end
    end"
Ronin::Model::HasAuthors::ClassMethods,written_by,(XXX) -> XXX,(String) -> Array<Model>,"def written_by(name)
          all('authors.name.like' => ""%#{name}%"")
        end"
Ronin::Model::HasAuthors::ClassMethods,written_for,(XXX) -> XXX,(String) -> Array<Model>,"def written_for(name)
          all('authors.organization.like' => ""%#{name}%"")
        end"
Ronin::Model::HasDescription::ClassMethods,describing,(XXX) -> XXX,(String) -> Array<Model>,"def describing(fragment)
          all(:description.like => ""%#{fragment}%"")
        end"
Ronin::Model::HasLicense::ClassMethods,licensed_under,([ to_s: () -> String ]) -> XXX,([ to_s: () -> String ]) -> Array<Model>,"def licensed_under(license)
          conditions = case license
                       when License
                         {:license => license}
                       when Symbol
                         {:license => License.predefined_resource(license)}
                       else
                         {'license.name' => license.to_s}
                       end

          all(conditions)
        end"
Ronin::Model::HasLicense::InstanceMethods,licensed_under,(XXX) -> XXX,((String or Symbol)) -> License,"def licensed_under(name)
          self.license = Ronin::License.predefined_resource(name)
        end"
Ronin::Model::HasLicense::InstanceMethods,license!,(XXX) -> XXX,() -> %bot,"def license!(name)
          licensed_under(name)
        end"
Ronin::Model::HasName::InstanceMethods,to_s,() -> String,() -> String,"def to_s
          self.name.to_s
        end"
Ronin::Model::HasUniqueName::InstanceMethods,to_s,() -> String,() -> String,"def to_s
          self.name.to_s
        end"
Ronin::Model::HasUniqueName::InstanceMethods,inspect,() -> String,() -> String,"def inspect
          ""#<#{self.class}: #{self.name}>""
        end"
Ronin::Model::InstanceMethods,humanize_attributes,"(?[ []: (:exclude) -> XXX ]) { (([ []: (Range<Number>) -> XXX ] and [ to_s: () -> String ]), ([ empty?: () -> XXX ] and [ nil?: () -> XXX ] and [ respond_to?: (:empty?) -> XXX ])) -> XXX } -> Hash<XXX, XXX>","(Hash) -> Hash<String, String>","def humanize_attributes(options={})
        exclude = [:id, :type]

        if options[:exclude]
          exclude += options[:exclude]
        end

        formatter = lambda { |value|
          case value
          when Array
            RDL.type_cast(value.map(&formatter), ""Array<String>"").join(', ')
          when Symbol
            DataMapper::Inflector.humanize(value)
          else
            value.to_s
          end
        }

        formatted = {}

        self.attributes.each do |name,value|
          next if (value.nil? || (value.respond_to?(:empty?) && value.empty?))

          unless (exclude.include?(name) || value.nil?)
            name = name.to_s

            unless name[-3..-1] == '_id'
              name = DataMapper::Inflector.humanize(name)
              value = formatter.call(value)

              yield name, value if block_given?

              formatted[name] = value
            end
          end
        end

        return formatted
      end"
Ronin::Model::Types::Description,typecast,(([ nil?: () -> XXX ] and [ to_s: () -> String ])) -> String,(Object) -> String,"def typecast(value)
          return nil if value.nil?

          sanitized_lines = []

          value.to_s.each_line do |line|
            sanitized_lines << line.strip
          end

          return sanitized_lines.join(""\n"").strip
        end"
Ronin::Script::Buildable,built?,() -> (false or true),() -> (false or true),"def built?
        @built == true
      end"
Ronin::Script::Buildable,build_failed!,(String) -> XXX,() -> %bot,"def build_failed!(message)
        raise(BuildFailed,message)
      end"
Ronin::Script::Buildable,build,() -> Ronin::Script::Buildable,() -> Script,"def build(&block)
        @build_blocks << block
        return self
      end"
Ronin::Script::Deployable,deployed?,() -> (false or true),() -> (false or true),"def deployed?
        @deployed == true
      end"
Ronin::Script::Deployable,evacuated?,() -> (false or true),() -> (false or true),"def evacuated?
        @evacuated == true
      end"
Ronin::Script::Deployable,deploy_failed!,(String) -> XXX,() -> %bot,"def deploy_failed!(message)
        raise(DeployFailed,message)
      end"
Ronin::Script::Deployable,deploy,() -> Ronin::Script::Deployable,() -> Script,"def deploy(&block)
        @deploy_blocks << block
        return self
      end"
Ronin::Script::Deployable,evacuate,() -> Ronin::Script::Deployable,() -> Script,"def evacuate(&block)
        @evacuate_blocks.unshift(block)
        return self
      end"
Ronin::Script::Path,class_path,() -> nil,() -> String,"def class_path
        if self.class_name
          DataMapper::Inflector.underscore(self.class_name)
        end
      end"
Ronin::Script::Path,script_class,() -> XXX,() -> Class,"def script_class
        return unless self.class_name

        # filter out unloadable script classes
        begin
          require class_path
        rescue Gem::LoadError => e
          raise(e)
        rescue ::LoadError
        end

        # filter out missing class names
        loaded_class = begin
                         DataMapper::Ext::Object.full_const_get(self.class_name)
                       rescue NameError
                         return nil
                       end

        # filter out non-script classes
        return loaded_class if RDL.type_cast(loaded_class, ""Class"") < Script
      end"
Ronin::Script::Path,cached_script,() -> nil,() -> Model,"def cached_script
        if (cached_class = script_class)
          return cached_class.first(:script_path => self)
        end
      end"
Ronin::Script::Path,updated?,() -> (false or true),() -> (false or true),"def updated?
        # assume updates if there is no timestamp
        return true unless self.timestamp

        if File.file?(self.path)
          return self.path.mtime > self.timestamp
        end

        # do not assume updates, if there is no path
        return false
      end"
Ronin::Script::Path,missing?,() -> XXX,() -> (false or true),"def missing?
        !(self.path.file?)
      end"
Ronin::Script::Path,cache,() -> (false or true),() -> (false or true),"def cache
        if (new_script = load_script)
          # reset the model-class
          self.class_name = new_script.class.to_s

          # update the timestamp
          self.timestamp = self.path.mtime

          # re-cache the newly loaded script
          new_script.script_path = self

          if new_script.save
            @cache_errors = nil
            return true
          else
            @cache_errors = new_script.errors
          end
        end

        return false
      end"
Ronin::Script::Path,sync,() -> (false or true),() -> (false or true),"def sync
        if missing?
          # destroy the cached file, if the actual file is missing
          return destroy
        elsif updated?
          # clean the previously cached file
          clean

          # if we couldn't cache anything, self-destruct
          destroy unless cache
          return true
        end

        return false
      end"
Ronin::Script::Path,clean,() -> nil,() -> %bot,"def clean
        if (script = cached_script)
          # destroy the previously cached object
          script.destroy!
        end
      end"
Ronin::Script::Path,to_s,() -> String,() -> String,"def to_s
        self.path.to_s
      end"
Ronin::Script::ClassMethods,short_name,() -> String,() -> String,"def short_name
        @short_name ||= RDL.type_cast(self.name, ""String"").split('::').last
      end"
Ronin::Script::ClassMethods,load_from,(XXX) -> XXX,(String) -> Script,"def load_from(path)
        load_object(path)
      end"
Ronin::Script::ClassMethods,load_all,(?XXX) -> Array<Ronin::Script::InstanceMethods>,(Hash) -> %bot,"def load_all(attributes={})
        resources = RDL.type_cast(all(attributes), ""Array<Ronin::Script::InstanceMethods>"")
        resources.each { |resource| resource.load_script! }

        return resources
      end"
Ronin::Script::ClassMethods,load_first,(?XXX) -> XXX,(Hash) -> Cacheable,"def load_first(attributes={})
        if (resource = first(attributes))
          RDL.type_cast(resource, ""Ronin::Script::InstanceMethods"").load_script!
        end

        return resource
      end"
Ronin::Script::InstanceMethods,script_loaded?,() -> (false or true),() -> (false or true),"def script_loaded?
        @script_loaded == true
      end"
Ronin::Script::InstanceMethods,prepared_for_cache?,() -> (false or true),() -> (false or true),"def prepared_for_cache?
        @cache_prepared == true
      end"
Ronin::Script::InstanceMethods,cached?,() -> XXX,() -> (false or true),"def cached?
        (saved? && self.script_path)
      end"
Ronin::Script::InstanceMethods,run,(*XXX) -> nil,(Array) -> %bot,"def run(*arguments)
      end"
Ronin::Script::InstanceMethods,inspect,() -> String,() -> String,"def inspect
        body = []

        RDL.type_cast(self.attributes, ""Hash<String, String>"").each do |name,value|
          body << ""#{name}: #{value.inspect}""
        end

        param_pairs = []

        RDL.type_cast(self.params, ""Hash<String, Ronin::URLQueryParam>"").each do |name,param|
          param_pairs << ""#{name}: #{param.value.inspect}""
        end

        body << ""params: {#{param_pairs.join(', ')}}""

        return ""#<#{self.class}: #{body.join(', ')}>""
      end"
Ronin::Script::InstanceMethods,cache,() { () -> XXX } -> (false or true),() -> (false or true),"def cache
        if (block_given? && !(cached? || prepared_for_cache?))
          @cache_prepared = true

          yield
          return true
        end

        return false
      end"
Ronin::Script::Testable,test!,() -> (false or true),() -> (false or true),"def test!
        print_info ""Testing #{RDL.type_cast(self.class, ""Ronin::Script::ClassMethods"").short_name} ...""

        @test_blocks.each { |block| block.call() }

        print_info ""#{RDL.type_cast(self.class, ""Ronin::Script::ClassMethods"").short_name} tested!""
        return true
      end"
Ronin::Script::Testable,flunk,(String) -> XXX,(String) -> %bot,"def flunk(message)
        raise(TestFailed,message)
      end"
Ronin::Script::Testable,test,() -> Ronin::Script::Testable,() -> Script,"def test(&block)
        @test_blocks << block
        return self
      end"
Ronin::Script::Testable,test?,(String) { XXX } -> Ronin::Script::Testable,(String) -> (false or true),"def test?(message,&block)
        test { flunk(message) unless block.call() }
      end"
Ronin::Script::Testable,test_equal,"((String or Symbol), [ inspect: () -> XXX ], ?String) -> Ronin::Script::Testable","(Symbol, Object, String) -> (false or true)","def test_equal(name,expected_value,message=nil)
        name = name.to_sym

        test do
          actual_value = RDL.type_cast(self.send(name), ""Object"")
          message ||= ""#{name} (#{actual_value.inspect}) must equal #{expected_value.inspect}""

          flunk(message) unless actual_value == expected_value
        end
      end"
Ronin::Script::Testable,test_not_equal,"((String or Symbol), [ inspect: () -> XXX ], ?String) -> Ronin::Script::Testable","(Symbol, Object, String) -> (false or true)","def test_not_equal(name,unexpected_value,message=nil)
        name = name.to_sym

        test do
          actual_value = RDL.type_cast(self.send(name), ""Object"")
          message ||= ""#{name} (#{actual_value.inspect}) cannot equal #{unexpected_value.inspect}""

          flunk(message) unless actual_value != unexpected_value
        end
      end"
Ronin::Script::Testable,test_set,"((String or Symbol), ?String) -> Ronin::Script::Testable","(Symbol, String) -> (false or true)","def test_set(name,message=nil)
        name = name.to_sym

        test do
          actual_value = RDL.type_cast(self.send(name), ""Object"")
          message ||= ""#{name} is not set""

          blank = if actual_value.respond_to?(:empty?)
                    actual_value.empty?
                  else
                    actual_value.nil?
                  end

          flunk(message) if blank
        end
      end"
Ronin::Script::Testable,test_match,"((String or Symbol), (Regexp or String), ?String) -> Ronin::Script::Testable","(Symbol, (Regexp or String), String) -> (false or true)","def test_match(name,pattern,message=nil)
        name = name.to_sym

        test do
          actual_value = RDL.type_cast(self.send(name), ""String"")
          message ||= ""#{name} (#{actual_value.inspect}) must match #{pattern.inspect}""

          flunk(message) unless actual_value.match(pattern)
        end
      end"
Ronin::Script::Testable,test_no_match,"((String or Symbol), (Regexp or String), ?String) -> Ronin::Script::Testable","(Symbol, (Regexp or String), String) -> (false or true)","def test_no_match(name,pattern,message=nil)
        name = name.to_sym

        test do
          actual_value = RDL.type_cast(self.send(name), ""String"")
          message ||= ""#{name} (#{actual_value.inspect}) cannot match #{pattern.inspect}""

          flunk(message) unless !actual_value.match(pattern)
        end
      end"
Ronin::Script::Testable,test_in,"((String or Symbol), ([ include?: (String) -> XXX ] and [ inspect: () -> XXX ]), ?String) -> Ronin::Script::Testable","(Symbol, String) -> (false or true)","def test_in(name,expected_values,message=nil)
        name = name.to_sym

        test do
          actual_value = RDL.type_cast(self.send(name), ""String"")
          message ||= ""#{name} (#{actual_value.inspect}) must be one of #{expected_values.inspect}""

          flunk(message) unless expected_values.include?(actual_value)
        end
      end"
Ronin::Script::Testable,test_not_in,"((String or Symbol), ([ include?: (String) -> XXX ] and [ inspect: () -> XXX ]), ?String) -> Ronin::Script::Testable","(Symbol, String) -> (false or true)","def test_not_in(name,unexpected_values,message=nil)
        name = name.to_sym

        test do
          actual_value = RDL.type_cast(self.send(name), ""String"")
          message ||= ""#{name} (#{actual_value.inspect}) cannot be one of #{unexpected_values.inspect}""

          flunk(message) unless !unexpected_values.include?(actual_value)
        end
      end"
Ronin::UI::CLI::ClassCommand,option_parser,() { (XXX) -> XXX } -> OptionParser,() -> OptionParser,"def option_parser
          super do |opts|
            @object.each_param do |param|
              Parameters::Options.define(opts,param)
            end

            yield opts if block_given?
          end
        end"
Ronin::UI::CLI::Command,initialize,(?XXX) -> self,"(Hash<Symbol, Object>) -> self","def initialize(options={})
          super()

          initialize_params(options)
        end"
Ronin::UI::CLI::Command,start,(?XXX) -> (false or true),(Array<String>) -> (false or true),"def start(argv=ARGV)
          arguments = option_parser.parse(argv)

          # set additional arguments
          self.class.each_argument do |name|
            # no more arguments left
            break if arguments.empty?

            param = get_param(name)

            if param.type <= Parameters::Types::Array
              # allow Array/Set arguments to collect all remaining args
              param.value = arguments.shift(arguments.length)
            else
              param.value = arguments.shift
            end
          end

          unless arguments.empty?
            print_error ""Too many arguments. Please consult --help""
            exit -1
          end

          begin
            run
          rescue Interrupt
            # Ctrl^C
            exit 130
          rescue Errno::EPIPE
            # STDOUT was closed
          rescue => error
            print_exception(error)
            exit -1
          end

          return true
        end"
Ronin::UI::CLI::Command,run,(?XXX) -> (false or true),"(Hash<Symbol, Object>) -> (false or true)","def run(options={})
          self.params = options

          setup
          execute

          return true
        ensure
          cleanup
        end"
Ronin::UI::CLI::Command,setup,() -> XXX,() -> %bot,"def setup
          Output.verbose! if verbose?
          Output.quiet!   if quiet?
          Output.silent!  if silent?

          Output.handler = if color? then Output::Terminal::Color
                           else           Output::Terminal::Raw
                           end
        end"
Ronin::UI::CLI::Command,execute,() -> nil,() -> %bot,"def execute
        end"
Ronin::UI::CLI::Command,cleanup,() -> nil,() -> %bot,"def cleanup
        end"
Ronin::UI::CLI::Command,option_parser,() { (([ banner: () -> XXX ] and [ banner=: (String) -> XXX ] and [ separator: (String) -> XXX ])) -> nil } -> OptionParser,() -> OptionParser,"def option_parser
          OptionParser.new do |opts|
            opts.banner = ""Usage: ronin #{self.class.command_name} #{self.class.usage}""

            # append the arguments to the banner
            self.class.each_argument do |name|
              opts.banner << "" #{name.to_s.upcase}""
            end

            opts.separator ''
            opts.separator 'Options:'

            self.class.each_option do |name,options|
              Parameters::Options.define(opts,get_param(name),options)
            end

            yield opts if block_given?

            if self.class.arguments?
              opts.separator ''
              opts.separator 'Arguments:'

              self.class.each_argument do |name|
                param = get_param(name)
                name  = name.to_s.upcase
                desc  = param.description

                opts.separator ""    #{name.ljust(33)}#{desc}""
              end
            end

            unless self.class.examples.empty?
              opts.separator ''
              opts.separator 'Examples:'

              self.class.examples.each do |example|
                opts.separator ""  #{example}""
              end
            end

            if self.class.summary
              opts.separator ''
              opts.separator self.class.summary
            end
          end
        end"
Ronin::UI::CLI::ModelCommand,setup,() -> (false or true),() -> %bot,"def setup
          super

          if @database
            Database.repositories[:default] = @database
          end

          Database.setup
        end"
Ronin::UI::CLI::Printing,initialize,() -> self,() -> %bot,"def initialize
          @indent = 0
        end"
Ronin::UI::CLI::Printing,indent,"(?Number) { () -> (Hash<XXX, XXX> or String) } -> nil",(Number) -> nil,"def indent(n=2)
          @indent += n

          yield

          @indent -= n
          return nil
        end"
Ronin::UI::CLI::Printing,print_title,(XXX) -> nil,(String) -> %bot,"def print_title(title)
          puts ""[ #{title} ]\n""
        end"
Ronin::UI::CLI::Printing,print_section,(XXX) { XXX } -> nil,() -> %bot,"def print_section(title,&block)
          print_title(title)
          indent(&block)
        end"
Ronin::UI::CLI::Printing,print_array,"([ each: () {(XXX) -> XXX} -> XXX ], ?[ []: (:title) -> XXX ]) -> nil","(Array, Hash) -> nil","def print_array(array,options={})
          print_title(options[:title]) if options[:title]

          indent do
            array.each { |value| puts value }
          end

          puts if options[:title]
          return nil
        end"
Ronin::UI::CLI::Printing,print_hash,"(([ each: () {(XXX, XXX) -> XXX} -> XXX ] and [ keys: () -> XXX ]), ?[ []: (:title) -> XXX ]) -> nil","(Hash, Hash) -> nil","def print_hash(hash,options={})
          align = hash.keys.map { |name|
            name.to_s.length
          }.max

          print_title(options[:title]) if options[:title]

          indent do
            hash.each do |name,value|
              name = ""#{name}:"".ljust(align)
              puts ""#{name}\t#{value}""
            end
          end

          puts if options[:title]
          return nil
        end"
Ronin::UI::CLI::ResourcesCommand,execute,() -> XXX,() -> %bot,"def execute
          if @import
            self.class.model.import(@import) do |resource|
              print_info ""Imported #{resource}""
            end
          else
            print_resources(query)
          end
        end"
Ronin::UI::CLI::ResourcesCommand,print_resource,([ to_s: () -> String ]) -> nil,(DataMapper::Resource) -> %bot,"def print_resource(resource)
          puts resource
        end"
Ronin::UI::CLI::ResourcesCommand,print_resources,(([ each: () {(XXX) -> XXX} -> XXX ] and [ to_csv: () -> XXX ] and [ to_json: () -> XXX ] and [ to_xml: () -> XXX ] and [ to_yaml: () -> XXX ])) -> XXX,(DataMapper::Collection) -> %bot,"def print_resources(resources)
          if    csv?  then print resources.to_csv
          elsif xml?  then print resources.to_xml
          elsif yaml? then print resources.to_yaml
          elsif json? then print resources.to_json
          else
            resources.each { |resource| print_resource(resource) }
          end
        end"
Ronin::UI::CLI::ScriptCommand,initialize,(?XXX) -> self,"(Hash<Symbol, Object>) -> self","def initialize(options={})
          super(options)

          @script_options = []
        end"
Ronin::UI::CLI::ScriptCommand,start,"(?([ []: (Number, (XXX or XXX)) -> XXX ] and [ index: (String) -> XXX ] and [ length: () -> XXX ])) -> (false or true)",(Array<String>) -> %bot,"def start(argv=ARGV)
          # collect the script options, upto the -- separator
          @script_options = argv[0,argv.index('--') || argv.length]

          super(argv)
        end"
Ronin::UI::CLI::ScriptCommand,setup,() -> XXX,() -> %bot,"def setup
          super

          load!
          param_option_parser.parse(@param_options)
        end"
Ronin::UI::CLI::ScriptCommand,execute,() -> XXX,() -> %bot,"def execute
          if @console
            print_info ""Starting the console with @script set ...""

            UI::Console.start(:script => @script)
          else
            @script.run
          end
        end"
Ronin::UI::CLI::ScriptCommand,load!,() -> XXX,() -> Script,"def load!
          @script = if @file then self.class.model.load_from(@file)
                    else          query.load_first
                    end

          unless @script
            print_error ""Could not find or load the #{self.class.script_class.short_name}""
            exit -1
          end
        end"
Ronin::UI::CLI::ScriptCommand,param_option_parser,() { (([ banner=: (String) -> XXX ] and [ separator: (String) -> XXX ])) -> XXX } -> OptionParser,(Array<Parameters>) -> OptionParser,"def param_option_parser
          OptionParser.new do |opts|
            opts.banner = ""usage: #{self.class.command_name} #{@script_options.join(' ')} -- [script_options]""
            
            opts.separator ''
            opts.separator ""#{self.class.script_class.short_name} Options:""

            @script.each_param do |param|
              Parameters::Options.define(opts,param)
            end

            yield opts if block_given?
          end
        end"
Ronin::UI::CLI::Commands::Campaigns,execute,() -> nil,() -> %bot,"def execute
            if    add?  then add(@add)
            elsif list? then super
            end
          end"
Ronin::UI::CLI::Commands::Campaigns,print_resource,(([ description: () -> XXX ] and [ name: () -> XXX ] and [ organizations: () -> XXX ] and [ targets: () -> XXX ] and [ to_s: () -> String ])) -> nil,(Campaign) -> %bot,"def print_resource(campaign)
            return super(campaign) unless verbose?

            print_title campaign.name

            indent do
              if campaign.description
                print_section 'Description' do
                  campaign.description.each_line do |line|
                    puts line
                  end
                end
              end

              unless campaign.organizations.empty?
                print_array campaign.organizations, :title => 'Targeted Organizations'
              end

              unless campaign.targets.empty?
                print_array campaign.targets, :title => 'Targets'
              end
            end
          end"
Ronin::UI::CLI::Commands::Console,setup,() -> nil,() -> %bot,"def setup
            super

            UI::Console.color = color?
            UI::Console.short_errors = !backtrace?

            @require.each do |path|
              UI::Console.auto_load << path
            end

            if database?
              Database.repositories[:default] = @database
            end
          end"
Ronin::UI::CLI::Commands::Console,execute,() -> nil,() -> %bot,"def execute
            if version?
              puts ""ronin #{Ronin::VERSION}""
              return
            end

            UI::Console.start
          end"
Ronin::UI::CLI::Commands::Creds,execute,() -> nil,() -> %bot,"def execute
            super if list?
          end"
Ronin::UI::CLI::Commands::Creds,print_resource,([ to_s: () -> String ]) -> nil,(Credential) -> %bot,"def print_resource(cred)
            case cred
            when ServiceCredential
              puts ""#{cred}\t(#{cred.open_port.ip_address} #{cred.open_port})""
            when WebCredential
              puts ""#{cred}\t(#{cred.url})""
            else
              super(cred)
            end
          end"
Ronin::UI::CLI::Commands::Exec,initialize,"(((IO or String) and [ dump: () -> XXX ] and [ to_str: () -> String ]), ?Array<String>) -> self","(String, Array<String>) -> self","def initialize(script,arguments=[])
            @script = script
            @arguments = arguments
          end"
Ronin::UI::CLI::Commands::Exec,execute,() -> (false or true),() -> %bot,"def execute
            if File.file?(@script)
              require 'ronin'

              setup_argv { load File.expand_path(@script) }
              return true
            end

            Database.setup

            Repository.each do |repo|
              path = repo.path.join(Repository::BIN_DIR,@script)

              if path.file?
                require 'ronin'

                repo.activate!

                setup_argv { load path }
                return true
              end
            end

            print_error ""Could not find the script #{@script.dump}.""
            return false
          end"
Ronin::UI::CLI::Commands::Exec,setup_argv,() { () -> (false or true) } -> (false or true),() -> %bot,"def setup_argv
            original_argv = ARGV.dup
            ARGV.clear
            @arguments.each { |arg| ARGV << arg }

            result = yield

            ARGV.clear
            original_argv.each { |arg| ARGV << arg }
            return result
          end"
Ronin::UI::CLI::Commands::Fuzzer,setup,() -> Number,() -> %bot,"def setup
            super

            unless rules?
              print_error ""Must specify at least one fuzzing rule""
              exit -1
            end

            @rules = Hash[@rules.map { |pattern,substitution|
              [parse_pattern(pattern), parse_substitution(substitution)]
            }]

            if output?
              @file_ext  = File.extname(@output)
              @file_name = @file.chomp(@file_ext)
            elsif command?
              @command = shellwords(@command)
            elsif (tcp? || udp?)
              @socket_class = if    tcp? then TCPSocket
                              elsif udp? then UDPSocket
                              end

              @host, @port = (@tcp || @udp).split(':',2)
              @port = @port.to_i
            end
          end"
Ronin::UI::CLI::Commands::Fuzzer,execute,() -> XXX,() -> %bot,"def execute
            data   = if input? then File.read(@input)
                     else           $stdin.read
                     end

            method = if    output?        then method(:fuzz_file)
                     elsif command?       then method(:fuzz_command)
                     elsif (tcp? || udp?) then method(:fuzz_network)
                     else                      method(:print_fuzz)
                     end

            fuzzer = Fuzzing::Fuzzer.new(@rules)
            fuzzer.each(data).each_with_index do |string,index|
              index = index + 1

              method.call(string,index)
            end
          end"
Ronin::UI::CLI::Commands::Fuzzer,fuzz_file,"(String, XXX) -> Number","(String, Number) -> %bot","def fuzz_file(string,index)
            path = ""#{@file_name}-#{index}#{@file_ext}""

            print_info ""Creating file ##{index}: #{path} ...""

            File.open(path,'wb') do |file|
              file.write string
            end
          end"
Ronin::UI::CLI::Commands::Fuzzer,fuzz_command,"(String, XXX) -> nil","(String, Number) -> %bot","def fuzz_command(string,index)
            RDL.type_cast(Tempfile, ""${File}"").open(""ronin-fuzzer-#{index}"") do |tempfile|
              tempfile.write(string)
              tempfile.flush

              arguments = @command.map do |argument|
                if argument.include?('#path#')
                  argument.sub('#path#',tempfile.path)
                elsif argument.include?('#string#')
                  argument.sub('#string#',string)
                else
                  argument
                end
              end

              print_info ""Running command #{index}: #{arguments.join(' ')} ...""

              # run the command as it's own process
              unless system(*arguments)
                status = $?

                if status.coredump?
                  # jack pot!
                  print_error ""Process ##{status.pid} coredumped!""
                else
                  # process errored out
                  print_warning ""Process ##{status.pid} exited with status #{status.exitstatus}""
                end
              end
            end
          end"
Ronin::UI::CLI::Commands::Fuzzer,fuzz_network,"([ inspect: () -> XXX ], XXX) -> XXX","(String, Number) -> %bot","def fuzz_network(string,index)
            print_debug ""Connecting to #{@host}:#{@port} ...""
            socket = RDL.type_cast(@socket_class, ""${TCPSocket} or ${UDPSocket}"").new(@host,@port)

            print_info ""Sending message ##{index}: #{string.inspect} ...""
            socket.write(string)
            socket.flush

            print_debug ""Disconnecting from #{@host}:#{@port} ...""
            socket.close
          end"
Ronin::UI::CLI::Commands::Fuzzer,print_fuzz,"([ to_s: () -> String ], XXX) -> nil","(String, Number) -> %bot","def print_fuzz(string,index)
            print_debug ""String ##{index} ...""

            puts string
          end"
Ronin::UI::CLI::Commands::Fuzzer,parse_pattern,((Object and [ []: (Range<Number>) -> XXX ] and [ upcase: () -> XXX ])) -> Object,(String) -> (Regexp or String),"def parse_pattern(string)
            case string
            when /^\/.+\/$/
              Regexp.new(string[1..-2])
            when /^[a-z][a-z_]+$/
              const = string.upcase

              if (Regexp.const_defined?(const) &&
                  Regexp.const_get(const).kind_of?(Regexp))
                Regexp.const_get(const)
              else
                string
              end
            else
              string
            end
          end"
Ronin::UI::CLI::Commands::Fuzzer,parse_substitution,"(([ include?: (String) -> XXX ] and [ split: (String, Number) -> XXX ])) -> XXX",(String) -> Enumerator,"def parse_substitution(string)
            if string.include?('*')
              string, lengths = string.split('*',2)

              lengths = if lengths.include?('-')
                          min, max = lengths.split('-',2)

                          (min.to_i .. max.to_i)
                        else
                          lengths.to_i
                        end

              Fuzzing::Repeater.new(lengths).each(string)
            else
              Fuzzing[string]
            end
          end"
Ronin::UI::CLI::Commands::Help,execute,() -> nil,() -> %bot,"def execute
            if command?
              name = command.gsub(/^ronin-/,'')

              unless CLI.commands.include?(name)
                print_error ""Unknown command: #{@command.dump}""
                exit -1
              end

              man_page = ""ronin-#{name.tr(':','-')}.1""

              Installation.paths.each do |path|
                man_path = File.join(path,'man',man_page)

                if File.file?(man_path)
                  return system('man',man_path)
                end
              end

              print_error ""No man-page for the command: #{@command.dump}""
              exit -1
            end

            print_array CLI.commands, :title => 'Available commands'
          end"
Ronin::UI::CLI::Commands::Hosts,execute,() -> XXX,() -> %bot,"def execute
            if lookup? then lookup(@lookup)
            else            super
            end
          end"
Ronin::UI::CLI::Commands::Hosts,print_resource,(([ address: () -> XXX ] and [ email_addresses: () -> XXX ] and [ ip_addresses: () -> XXX ] and [ last_scanned_at: () -> XXX ] and [ open_ports: () -> XXX ] and [ organization: () -> XXX ] and [ to_s: () -> String ] and [ urls: () -> XXX ])) -> nil,(HostName) -> %bot,"def print_resource(host)
            return super(host) unless verbose?

            print_title host.address

            indent do
              if (org = host.organization)
                print_hash 'Organization' => org
              end

              if (last_scanned_at = host.last_scanned_at)
                print_hash 'Last Scanned' => last_scanned_at
              end

              unless host.ip_addresses.empty?
                print_array host.ip_addresses, :title => 'IP Addresses'
              end

              unless host.open_ports.empty?
                print_section 'Open Ports' do
                  host.open_ports.each do |port|
                    if port.service
                      puts ""#{port}\t#{port.service}""
                    else
                      puts port
                    end
                  end
                end
              end

              unless host.email_addresses.empty?
                print_array host.email_addresses, :title => 'Email Addresses'
              end

              unless host.urls.empty?
                print_array host.urls, :title => 'URLs'
              end
            end
          end"
Ronin::UI::CLI::Commands::Install,setup,() -> (false or true),() -> %bot,"def setup
            super

            Database.setup
          end"
Ronin::UI::CLI::Commands::Install,execute,() -> XXX,() -> %bot,"def execute
            unless uri?
              print_error ""Must specify the URI argument""
              exit -1
            end

            scm = if    rsync? then :rsync
                  elsif svn?   then :sub_version
                  elsif hg?    then :mercurial
                  elsif git?   then :git
                  end

            repository = RDL.type_cast(begin
                           if File.directory?(@uri)
                             # add local repositories
                             Repository.add(:path => @uri, :scm => scm)
                           else
                             # install remote repositories
                             Repository.install(:uri => @uri, :scm => scm)
                           end
                         rescue DuplicateRepository => e
                           print_error e.message
                           exit -1
                         end, ""Ronin::Repository"")

            print_info ""Repository #{repository} installed.""

            # print any caching exceptions/errors
            repository.script_paths.each do |script_path|
              if script_path.cache_exception
                print_exception script_path.cache_exception
              end

              if script_path.cache_errors
                script_path.cache_errors.each do |error|
                  print_error error
                end
              end
            end
          end"
Ronin::UI::CLI::Commands::Ips,execute,() -> XXX,() -> %bot,"def execute
            if lookup? then lookup(@lookup)
            else            super
            end
          end"
Ronin::UI::CLI::Commands::Ips,print_resource,(([ address: () -> XXX ] and [ host_names: () -> XXX ] and [ last_scanned_at: () -> XXX ] and [ mac_addresses: () -> XXX ] and [ open_ports: () -> XXX ] and [ organization: () -> XXX ] and [ to_s: () -> String ])) -> nil,(IPAddress) -> %bot,"def print_resource(ip)
            return super(ip) unless verbose?

            print_title ip.address

            indent do
              if (org = ip.organization)
                print_hash 'Organization' => org
              end

              if (last_scanned_at = ip.last_scanned_at)
                print_hash 'Last Scanned' => last_scanned_at
              end

              unless ip.mac_addresses.empty?
                print_array ip.mac_addresses, :title => 'MAC Addresses'
              end

              unless ip.host_names.empty?
                print_array ip.host_names, :title => 'Hostnames'
              end

              unless ip.open_ports.empty?
                print_section 'Open Ports' do
                  ip.open_ports.each do |port|
                    if port.service
                      puts ""#{port}\t#{port.service}""
                    else
                      puts port
                    end
                  end
                end
              end
            end
          end"
Ronin::UI::CLI::Commands::Repos,execute,() -> nil,() -> %bot,"def execute
            if repo?
              repository = begin
                             Repository.find(@repo)
                           rescue RepositoryNotFound => e
                             print_error e.message
                             exit -1
                           end

              print_repository(repository)
            else
              print_array query
            end
          end"
Ronin::UI::CLI::Commands::Repos,print_repository,(([ description: () -> XXX ] and [ domain: () -> XXX ] and [ executables: () -> XXX ] and [ installed?: () -> XXX ] and [ name: () -> XXX ] and [ path: () -> XXX ] and [ scm: () -> XXX ] and [ script_paths: () -> XXX ] and [ source: () -> XXX ] and [ title: () -> XXX ] and [ uri: () -> XXX ] and [ verbose?: () -> XXX ] and [ website: () -> XXX ])) -> nil,(Repository) -> %bot,"def print_repository(repo)
            print_title repo.name

            indent do
              if repo.installed?
                puts ""Domain: #{repo.domain}""
              else
                puts ""Path: #{repo.path}""
              end

              puts ""SCM: #{repo.scm}"" if repo.scm

              if repo.verbose?
                putc ""\n""

                puts ""Title: #{repo.title}"" if repo.title
                puts ""URI: #{repo.uri}"" if repo.uri
                puts ""Source URI: #{repo.source}"" if repo.source
                puts ""Website: #{repo.website}"" if repo.website

                executables = repo.executables

                unless executables.empty?
                  puts ""Executables: #{executables.join(', ')}""
                end

                putc ""\n""

                unless repo.script_paths.empty?
                  print_title 'Cached Files'

                  indent do
                    repo.script_paths.each do |script_path|
                      puts script_path.path
                    end
                  end
                end

                if repo.description
                  print_title ""Description""

                  indent { puts ""#{repo.description}\n\n"" }
                else
                  putc ""\n""
                end
              else
                putc ""\n""
              end
            end
          end"
Ronin::UI::CLI::Commands::Uninstall,setup,() -> (false or true),() -> %bot,"def setup
            super

            Database.setup
          end"
Ronin::UI::CLI::Commands::Uninstall,execute,() -> XXX,() -> %bot,"def execute
            unless repo?
              print_error ""Must specify the REPO argument""
              exit -1
            end

            repository = Repository.uninstall(@repo)

            print_info ""Repository #{repository} uninstalled.""
          end"
Ronin::UI::CLI::Commands::Update,setup,() -> (false or true),() -> %bot,"def setup
            super

            Database.setup
          end"
Ronin::UI::CLI::Commands::Update,execute,() -> XXX,() -> %bot,"def execute
            if repo?
              repository = RDL.type_cast(begin
                             Repository.find(@repo)
                           rescue RepositoryNotFound => e
                             print_error e.message
                             exit -1
                           end, ""Ronin::Repository"")

              print_info ""Updating #{repository} ...""

              repository.update!

              print_info ""Repository #{repository} updated.""
            else
              print_info ""Updating Repositories ...""

              Repository.update!

              print_info ""Repositories updated.""
            end
          end"
Ronin::UI::CLI::Commands::Update,print_cache_errors,([ script_paths: () -> XXX ]) -> XXX,(Repository) -> %bot,"def print_cache_errors(repository)
            repository.script_paths.each do |script_path|
              if script_path.cache_exception
                print_exception script_path.cache_exception
              end

              if script_path.cache_errors
                script_path.cache_errors.each do |error|
                  print_error error
                end
              end
            end
          end"
Ronin::UI::CLI::Commands::Urls,print_resource,(([ fragment: () -> XXX ] and [ host_name: () -> XXX ] and [ last_scanned_at: () -> XXX ] and [ path: () -> XXX ] and [ port: () -> XXX ] and [ query_params: () -> XXX ] and [ to_s: () -> String ])) -> nil,(Ronin::URL) -> %bot,"def print_resource(url)
            return super(url) unless verbose?

            print_title url

            indent do
              print_hash 'Host' => url.host_name,
                         'Port' => url.port.number,
                         'Path' => url.path,
                         'Fragment' => url.fragment,
                         'Last Scanned' => url.last_scanned_at

              unless url.query_params.empty?
                params = {}

                url.query_params.each do |param|
                  params[param.name] = param.value
                end

                print_hash params, :title => 'Query Params'
              end
            end
          end"
Ronin::UI::CLI::Commands::Wordlist,execute,() -> XXX,() -> %bot,"def execute
            if (input? && template?)
              print_error ""Cannot specify --input with the TEMPLATE argument""
              exit -1
            end

            output_stream do |output|
              wordlist.each { |word| output.puts word }
            end
          end"
Ronin::UI::CLI::Commands::Wordlist,parse_template,() -> XXX,() -> Array<(Array<(Number or Symbol)> or Array<String> or String)>,"def parse_template
            @template.map do |char_template|
              if char_template.include?(':')
                charset, length = char_template.split(':',2)

                # convert charset names to Symbols
                charset = if charset.include?(',')
                            charset.split(',')
                          elsif Chars.const_defined?(charset.upcase)
                            charset.to_sym
                          else
                            charset.to_s
                          end

                # parse the length field
                length = if length.include?('-')
                           min, max = length.split('-',2)

                           Range.new(min.to_i,max.to_i)
                         elsif length.include?(',')
                           length.split(',').map(&:to_i)
                         else
                           length.to_i
                         end

                [charset, length]
              else
                char_template
              end
            end
          end"
Ronin::UI::CLI::Commands::Wordlist,wordlist,() -> Ronin::Wordlist,() -> Ronin::Wordlist,"def wordlist
            if template?
              generator = Fuzzing::Template.new(parse_template)

              Ronin::Wordlist.new(generator,@mutations)
            elsif input?
              Ronin::Wordlist.build(File.open(@input),@mutations)
            else
              Ronin::Wordlist.build($stdin,@mutations)
            end
          end"
Ronin::UI::CLI::Commands::Wordlist,output_stream,() { ([ puts: (XXX) -> XXX ]) -> XXX } -> XXX,() -> %bot,"def output_stream(&block)
            if @output
              File.open(@output,'w',&block)
            else
              yield $stdout
            end
          end"
